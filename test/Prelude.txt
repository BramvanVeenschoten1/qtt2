module Prelude

Bottom : Prop
Bottom = Pi (0 a : Prop), a

Top : Prop
Top = Bottom -o Bottom

tt : Top
tt = \x, x

And : Prop -> Prop -> Prop
And a b = Pi c : Prop, (a -> b -> c) -> c

And_left : Pi (a b : Prop), And a b -> a
And_left a b x = x a (\x y, x)

And_right : Pi (a b : Prop), And a b -> b
And_right a b x = x b (\x y, y)

And_intro : Pi (a b : Prop), a -> b -> And a b
And_intro a b x y _ f = f x y

Or : Prop -> Prop -> Prop
Or a b = Pi c : Prop, (a -> c) -> (b -> c) -> c

Or_left : Pi (a b : Prop), a -> Or a b
Or_left a b x _ f g = f x

Or_right : Pi (a b : Prop), b -> Or a b
Or_right a b x _ f g = g x 

Exists : Pi a : Type, (a -> Prop) -> Prop
Exists a p = Pi c : Prop, (Pi x : a, p x -> c) -> c

Exists_intro : Pi (a : Type)(p : a -> Prop)(x : a), p x -> Exists a p
Exists_intro a p x px _ f = f x px

Eq : Pi (a : Type), a -> a -> Prop
Eq a x y = Pi (0 p : a -> Prop), p x -o p y

Refl : Pi (a : Type)(x : a), Eq a x x
Refl a x p px = px

sym : Pi (a : Type)(x y : a), Eq a x y -> Eq a y x
sym a x y e = e (\z, Eq a z x) (Refl a x)

trans : Pi (a : Type)(x y z : a), Eq a x y -> Eq a y z -> Eq a x z
trans a x y z e1 e2 = e2 (Eq a x) e1

cong : Pi (a b : Type)(x y : a)(f : a -> b), Eq a x y -> Eq b (f x) (f y)
cong a b x y f e = e (\z, Eq b (f x) (f z)) (Refl b (f x))

proofIrrelevance : Pi (a : Prop)(x y : a), Eq a x y
proofIrrelevance a x y = Refl a x

K : Pi (a : Type)(x : a)(e : Eq a x x), Eq a (Lift 0 a x x e (\_, a) x) x
K a x e = Refl a x
  
liftBottom : Bottom => Pi (0 a : Type), a
liftBottom x a = Lift 1 Type Bottom a (x (Pi (0 p : Type -> Prop), p Bottom -o p a)) (\x, x) x

id : Pi (a : Type), a -> a
id a x = x

const : Pi (a b : Type), a -> b -> a
const a b x y = x

flip : Pi (a b c : Type), (a -> b -> c) -> (b -> a -> c)
flip a b c f x y = f y x

comp : Pi (a b c : Type), (b -> c) -> (a -> b) -> (a -> c)
comp a b c f g x = f (g x)

fork : Pi (a b c : Type), (a -> b -> c) -> (a -> b) -> a -> c
fork a b c f g x = f x (g x)



